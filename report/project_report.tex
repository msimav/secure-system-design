\documentclass[11pt]{report}

\usepackage[turkish]{babel}
\usepackage[utf8]{inputenc}

\usepackage[hidelinks]{hyperref} % use links

% Source Code
\usepackage{listings}
\renewcommand\lstlistingname{Kaynak Kod}

\title{\textbf{Bil 553} \\ İnternet ve Veri Güvenliği}
\author{Mustafa Simav \\
       091101036
    \and
        Burak Dikili \\
        091101062}
\date{Yaz 2013}
\begin{document}

\maketitle

\chapter{Giriş}

İnternet ve Veri Güvenliği dersi kapsamında, kullanıcıların kayıt olup giriş yapacakları, şifre değiştirme, şifre silme, kullanıcı hesabı silme gibi temel fonksiyonları olan bir sistemi güvenli bir şekilde tasarlamamız ve implement etmemiz gerekmektedir.

Bu raporda, proje kapsamında uyguladığımız güvenlik prensiplerinden bahsedip, bu prensipleri nasıl implement ettiğimizin detaylarını anlatacağız.

\section{Yapı}

Bu proje kapsamında gerçekleştireceğimiz uygulama bir web uygulaması olacaktır. Kullanıcılar internet tarayıcılarını kullanarak sistem ile etkileşim içinde olacaklardır. Değerli bilgiler, güvenli olmayan internet kanalı ile sunucu ve istemci arasında gidecektir. Bu nedenle güvenliğini sağlamamız gereken 3 yer vardır.

\begin{enumerate}
\item Sunucu güvenliği
\item İstemci güvenliği
\item Haberleşme kanalı güvenliği
\end{enumerate}

\section{Kullanılan Araçlar ve Kütüphaneler}

Bu sistemi yaparken kullanacağımız pek çok araç vardır. İlk olarak geliştireceğimiz uygulamayı \emph{Python} dili ile \emph{flask} framework'ünü kullanarak yazacağız. Ayrıca kullanıcı arayüzü için \emph{HTML} ve \emph{JavaScript} kullanacağız. Web uygulamamızı çalıştırabilmek için, web sunucu uygulaması olarak da \emph{uwsgi} ve \emph{nginx} kullanacağız. SSL desteğini de \emph{nginx} sayesinde kazanacağız. Bütün bu uygulamaların üzerinde çalıştığı işletim sistemi olarak da \emph{Debian} tercih ettik. Kullanıcı bilgilerini tutacağımız veri tabanı olarak da \emph{PostgreSQL}'i seçtik. Python ve PostgreSQL arasındaki iletişim için \emph{python-psycopg2} kütüphanesini, kripto araçları için \emph{pycrypto} kütüphanesini, kullanıcının IP adresine göre konumunu almak için \emph{pygeoip} kütüphanesini kullanıyoruz.

Kullandığımız bütün bu araçları liste halinde sunmamız gerekirse:

\begin{enumerate}
\item Debian 7 Wheezy 64 bit
\item python 2.7.3
\item uwsgi 1.9.13
\item flask 0.10
\item python-psycopg2 2.5.1
\item PostgreSQL 9.1
\item nginx 1.2.1
\item pycrypto 2.6
\item pygeoip 0.2.7
\end{enumerate}


\chapter{Temel Güvenlik}
\section{Hazır Kripto Kütüphanesi Kullanmak}
Kripto araçlarının tanımının açıkça yapılmış olması, bu araçların güvenliği için olmazsa olmaz şartlardan biridir. Auguste Kerckhoffs, "Bir kripto sistemi, sistem hakkındaki anahtar hariç her detay açıkça bilindiği halde bile güvenli olmalıdır."\cite{kerckhoffs} diyerek \emph{Kerckhoffs İlkesi} olarak bilinen ilkeyi ortaya atmıştır.

Fakat tanımı açık olsa da kripto araçlarını deneyimsiz insanların implement etmesi çeşitli güvenlik zaaflarına neden olmaktadır. Örnek vermek gerekirse, iki hash değeri karşılaştırılırken, fark görüldüğü anda algoritmanın sonlanması, zamanlama saldırılarına temel hazırlamaktadır.

Zamanlama saldırılarının ciddiyeti konusundaki en önemli örnek Java'nın standart kütüphanesinde yer alan \texttt{java.security.MessageDigest} sınıfının \texttt{isEqual} methodudur. Bu method implementasyonundaki nedeniyle zamanlama saldırılarına karşı zaafiyeti keşfedilmiştir. Bu zaafiyet Java SE 6 Update 17 güncellemesi ile kapatılmıştır \cite{javavul}.

Bu nedenlerden dolayı kripto ihtiyaçlarımızı, deneyimli insanlar tarafından implement edilmiş ve iyi test edilmiş kütüphaneler ile sağlamamız tavsiye edilmektedir. Biz de bu nedenle \emph{pycrypto} kütüphanesini kullanmaya karar verdik.

\chapter{Sunucu Tarafı Güvenliği}

\section{İşletim Sistemi Güvenliği}

Kullanıcı bilgilerinin güvenliğinin sağlanmasının ilk adımı, uygulamanın çalışacağı sunucu üzerinde güvenlik önlemleri almaktır. Bu önlemlerin ilk adımı da sunucu üzerinde çalışan işletim sisteminin güvenliğidir.

Biz işletim sistemi olarak \emph{Debian 7 Wheezy 64 Bit} kullanmayı seçtik. Aşağıdaki maddeler ile debian işletim sistemini nasıl daha güvenli yapabileceğimiz tartışılmaktadır.

\subsection{Güvenilir Kaynaklardan Yazılım Yüklemek}

GNU/Linux sistemler gerek kernel'inin yapısı gerekse üzerinde çalışan programların güvenliği temel ilke kabul etmelerinden dolayı güvenlidir \cite{linuxsec}. Sistemin güvenliği önündeki en büyük engel bilinmeyen kaynaklardan yazılım yüklemektir.

Biz yüklediğimiz bütün yazılımları \emph{Debian depolarından} yükleyerek bu sorunun önüne geçtik. Ayrıca debian depolarındaki yazılımlar güvenlik yamaları da yapılmış olduğu için işletim sisteminin yazılım bazında güvenliğini sağladık.

\subsection{Uzaktan Erişimin Güvenliğini Arttırmak}

Sunucu bilgisayara uzaktan erişim, oluşan hataların tespitini ve çözümünü kolaylaştıran çok önemli bir özelliktir. Debian kurulduğunda, şifrelenmiş bir bağlantı üzerinden uzaktan erişime imkan veren \emph{openssh} programı ile beraber gelir. Bu program güvenli iletişimi sağlar fakat saldırganın şifreyi kaba kuvvet ile deneyerek bulma imkanı vardır.

Bruteforce saldırılarını önlemek için yapılabilecek pek çok şey vardır \cite{blog}. Bunlardan en önemli ikisi şunlardır.

\begin{enumerate}
\item root kullanıcısının login özelliğini kapatmak
\item şifre ile login özelliğini kapatıp, sadece açık anahtar ile login olmak
\end{enumerate}

Biz bu iki yöntemi de uyguladık. Bunu yapmak için önce kendi ssh açık anahtarımızı sunucuya yerleştirdik ve ardından \texttt{/etc/ssh/sshd\_config} dosyasını aşağıdaki gibi değiştirdik.

\begin{lstlisting}[caption=OpenSSH Ayarları]
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
\end{lstlisting}

Bu yöntemlerden root kullanıcısının login özelliğini kısıtlamanın hiç bir sakıncası yoktur. Şifre ile oturum açmayı iptal etmeknin sakıncaları ile gizli anahtarımızın olmadığı bilgisayarlardan oturum açamama ve gizli anahtarı kaybetme durumunda saldırganın sunucuya erişim sağlamasıdır. Fakat biz güvenlik konusunda bilgili olduğumuz ve gizli anahtarlarımızın güvenliğini sağladığımız için bu bir sorun olmayacaktır.

\subsection{Güvenlik Duvarı}

Linux çekirdeği güçlü bir firewall olan \emph{iptables} ile birlikte gelmektedir. Basitçe ayarlandıktan sonra güçlü bir koruma sağlamaktadır.

\begin{lstlisting}[caption=IPtables Ayarları,basicstyle=\footnotesize]
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [748:52299]
:TCP - [0:0]
:UDP - [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m conntrack --ctstate INVALID -j DROP
-A TCP -p tcp --dport 80 -j ACCEPT
-A TCP -p tcp --dport 443 -j ACCEPT
-A TCP -p tcp --dport 22 -j ACCEPT
-A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT
-A INPUT -p udp -m conntrack --ctstate NEW -j UDP
-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack
                           --ctstate NEW -j TCP
-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable
-A INPUT -p tcp -j REJECT --reject-with tcp-reset
-A INPUT -j REJECT --reject-with icmp-proto-unreachable
COMMIT
\end{lstlisting}

Yukarıdaki gibi ayarlandığında iptables sadece 80, 443 ve 22 numaralı portlardan gelen istekleri kabul edecektir. Diğer bütün istekler \emph{iptables} tarafından düşürülecektir.

\section{Veri Tabanı Güvenliği}

Veritabanı, kullanıcı bilgilerinin saklandığı yer olduğu için saldırganlar veritabanına da saldıracaktır. Bu nedenle veritabanın güvenliğinin de sağlanması gerekmektedir. PostgreSQL veritabanı daha güvenli hale getirmek için yapılabilecek bir kaç küçük işlem vardır.

\subsection{Veri Tabanına Erişimi Kısıtlamak}

Veritabanına erişimin kısıtlanması, sunucuya sızmış olan saldırganın işlerini zorlaştıracaktır. Bu nedenle yapılması gereklidir.

Biz vertabanı olarak \emph{PostgreSQL} kullanıyoruz. \emph{PostgreSQL}'de kullanıcı oluşturmak için öncelikle \emph{postgres} kullanıcısı olarak oturum açmamız gereklidir. Bu nedenle \texttt{su - postgres} komutunu çalıştırılmalı ve ardından kullanıcı ve veritabanı eklenmelidir.

\begin{lstlisting}[caption=PostgreSQL Kullanıcı ve Verıtabanı Ekleme]
$ createuser guvenlik
$ createdb -O guvenlik guvenlik
\end{lstlisting}

Bu komutlar guvenlik isminde bir veritabanı ve bu veritabanını kullanma hakkı olan bir kullanıcı oluşturur. PostgreSQL'in varsayılan ayarlarına göre sadece \emph{guvenlik} ismindeki sistem kullanıcısı bu veritabanına erişebilir.

\subsection{SQL Injection Saldırılarına Karşı Önlem Almak}

Veritabanı üzerindeki diğer bir güvenlik tehtidi de \emph{SQL Injection} yöntemidir. Bu yöntem, kötü programcıların SQL ifadelerini string işlemleri ile oluşturmalarından dolayı oluşan bir açıktır.

Bu hatalara örnek, SQL ifadelerinin python string format operatörü olan \emph{\%} işareti ile oluşturmaktır.

\begin{lstlisting}[caption=Python-psycopg2 SQL Injection]
SQL = "SELECT * FROM users WHERE mail = %s AND passwd = %s" %
             (mail, passwd)
cursor.execute(SQL)
\end{lstlisting}

Bu hatalardan korunmanın yöntemi ise argümanları \texttt{execute} fonksiyonuna parametre olarak vermektir.

\begin{lstlisting}[caption=Python-psycopg2 SQL Injection]
SQL = "SELECT * FROM users WHERE mail = %s AND passwd = %s"
cursor.execute(SQL, (mail, passwd))
\end{lstlisting}

Biz de programın kodlaması sırasında SQL ifadelerimizi bu prensibe uygun oluşturduk.

\section{Uygulamanın Güvenliği}

Sunucu bilgisayarın ve veritabanının güvenliğini sağladıktan sonra, geliştirdiğimiz uygulama içinde de güvenlik önlemleri almamız gerekmektedir.

\subsection{Şifrelerin Açık Bir Şekilde Saklanmaması}

Şifrelerin veritabanında açıkça saklanması, veritabanının ele gecirilmesi durumunda kullanıcılar açısından sorun oluşturabilir. Bu nedenle şiflerelerin gizli bir şekilde saklanması daha uygundur.

Bu işlem için de kripto bize \emph{özet (hash) fonksiyonları} sunar. Hash fonksiyonu, $H: X \rightarrow Y$ üzerinde tanımlı, bire bir eşleme yapan, deterministik bir fonksiyondur. Yapısı gereği her şifre stringini bir hash değerine eşler. Bu nedenle şifre bilindiğinde, şifre kontrolü mümkün iken, hash bilindiğinde şifreye ulaşmak imkansızdır.

Biz de bu projede \emph{SHA256} algoritmasını kullanarak şifreleri saklıyor. \emph{SHA256}'yı şu anda kullanılması tavsiye edilen algoritma olduğu için seçtik.

\begin{lstlisting}[caption=Python SHA256 Kullanımı]
hash = SHA256.new()
hash.update(passwd)
message = hash.hexdigest()
\end{lstlisting}

\subsection{Hash İşlemi Sırasında Salt Kullanılması}

Şifrelerin sadece hash olarak saklanması yöntemi, çevrimdışı bir saldırı olan \emph{Rainbow Saldırılarına} karşı zaafiyet içermektedir. Bu nedenle şifrenin başına rastgele üretilen bir \emph{tuz (salt)} değeri koyularak, saldırganın elindeki önceden hesaplanmış tablo geçersiz hale getirilir.

Unix işletim sistemlerinde şifreler saklanırken 128 bitlik bir salt değeri kullanılmaktadır \cite{unixsalt}. Biz de bu nedenle \emph{pycryto} kütüphanesi içindeki \emph{kriptografik rastgele sayı üretici} ile 128 bitlik sayı üreterek bunu salt olarak kullanıyoruz.

\begin{lstlisting}[caption=Python salt ile SHA256 Kullanımı]
salt = Random.new().read(128)
hash = SHA256.new()
hash.update(salt + passwd)
message = hash.hexdigest()
\end{lstlisting}


\subsection{Hash İşlemini İteratif Yapılması}

Tuzlama yöntemi de elinde yeterince hesaplama gücü olan saldırganlara karşı tam güvenlik sağlamamaktadır. Bu işlemi zorlaştırmak için hash işlemi iteratif yapılabilir. Bu durumda saldırganın her girdi için harcayacağı işlem gücü artacak ve dolayısıyla şifreyi öğrenme olasılığı azalacaktır.

Hash işlemini 1000 kez yapmak, sunucu için çok küçük bir yük getircektir. Bu nedenle bu tekniği uygulamak sorun oluşturmayacaktır.

\begin{lstlisting}[caption=Python iteratif SHA256 Kullanımı]
def digest_passwd(passwd, salt):
    hash = SHA256.new()
    hash.update(salt + passwd)
    message = hash.digest()

    for i in range(1000):
        hash = SHA256.new()
        hash.update(message)
        message = hash.digest()

    return hash.hexdigest()
\end{lstlisting}

Yukarıdaki kod bizim implementasyonumuzdan alınmıştır. Şifreyi \emph{salt} kullanarak \emph{1000} kez hash'ler.
\subsection{Hash Karşılaştırırken Zamanlama Saldırılarından Kaçınma}
\chapter{Haberleşme Kanalı Güvenliği}

\section{İletişimin Şifrelenmesi için SSL protokolünü kullanmak}
\section{SSL Üzerinde Çalışan Protokolün Güvenliği}


\chapter{Kullanıcı Tarafı Güvenliği}
\section{Keylogger'lara Karşı Sanal Klavye}
\section{Fare Hareketlerinin Dinlenmesine Karşı Rastgele Tuşlar}
\section{Farklı Ülkelerden Oturum Açmaya Karşı Hesap Kilitleme}

\chapter{Sonuç}


\begin{thebibliography}{9}

\bibitem{kerckhoffs}
  Auguste Kerckhoffs,
  "La cryptographie militaire",
  \emph{Journal des sciences militaires},
  vol. IX,
  1883

\bibitem{javavul}
  Java SE 6 Update 17, \emph{Update Release Notes} \\
  \url{http://www.oracle.com/technetwork/java/javase/6u17-141447.html}

\bibitem{linuxsec}
  Jeffrey S. Smith,
  "Why customers are flocking to Linux",
  \emph{IBM},
  2008-06-03.

\bibitem{blog}
  Mustafa Simav, \\
  \url{http://msimav.net/2013/04/13/increasing-ssh-server-security/}

\bibitem{unixsalt}
  Alexander, Steven, 
  \emph{"Password Protection for Modern Operating Systems"},
  2004

\end{thebibliography}

\end{document}
